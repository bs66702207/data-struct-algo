// data-struct-algo
数据结构是给人看的，所以起始位置是1

//时间复杂度和空间复杂度
	间复杂度，用大O来表示，多数情况下，一般的循环容易计算出时间复杂度，注意常数项统一成O(1)，这里列举两个例子让你理解如何计算时间复杂度。
for(i=0; i<n; i++)
	for(j=i;j<n;j++)
	上面的程序，当i=0时，内循环n次；当i=1时，内循环n-1次，。。。，当i=n-1时，内循环1次，那么他们之和就是n+(n-1)+(n-2)+...+1=n(n+1)/2，所以时间复杂度等于O(n^2)。
	通过上面的例子知道了，时间复杂度的计算方法是如何计算出该程序的运行次数，并且取最高项。再看一个程序：
int i=0, n=100;
while(i<n) {
	i = i*2;
}
	上面的程序，需要进行x个2相乘才可以推出循环，也就是2^x=n，那么x=log2n，时间复杂度O(logn)

	常用的时间复杂度所耗费的时间从小到大依次是：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
	空间复杂度，S(n)=O(f(n))，f(n)为语句关于n所占存储空间的函数，一般情况让我们求“复杂度”是指时间复杂度。
	列举一个关于时间复杂度和空间复杂度的例子，要判断某年是不是闰年，你可能会花一点心思来写一个算法，每给一个年份，就可以通过这个算法计算得到是否闰年的结果。
	另外一种方法是，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，则此数组元素的值是1，如果不是元素的值则为0。
	第一种方法节省空间，但是每次输入年份的时候需要进行算法计算；第二种方法节省时间，但是内存中会被2050个元素数组占用。

//线性表List
	零个或者多个数据元素组成的有限序列，第一个无前驱，最后一个无后继。
	若将线性表记为（a1,…,ai-1,ai,ai+1,…an）,则表中ai-1领先于ai,ai领先于ai+1,称ai-1是ai的直接前驱元素,ai+1是ai的直接后继元素。
	1.线性表的顺序存储结构，在存、读数据时，时间复杂度是O(1)，在插入和删除非末尾数据时，时间复杂度是O(n)。它适合元素个数比较稳定，不经常插入和删除元素，而更多的操作是存取数据的应用。
	2.单链表(head|phead) -> (a1|p1) -> (a2|p2)-> ... -> (an|null)。其优势在于，如果顺序多次插入或者删除数据，可以获取链表i的位置，然后直接插入，或者删除。
